import sys
import sqlite3
import json
import psutil
import os
import numpy as np
import cv2
import matplotlib.pyplot as plt
from os import listdir
import warnings
import gc  # <-- For memory cleanup
warnings.filterwarnings("ignore")

from utils.visualization import visualize_detections, print_detections
from utils.matchers import find_matcher_matrix
from utils.bbox_filtering import find_bboxes

# Images Path
scene_folder = os.path.join('.', 'images', 'scenes')
model_folder = os.path.join('.', 'images', 'models')
video_folder = os.path.join('.', 'images', 'videos')
results_folder = os.path.join('.', 'images', 'results')
db_path = os.path.join('.', 'products.db')
export_file = os.path.join(results_folder, "detected_items.json")
os.makedirs(results_folder, exist_ok=True)

def fetch_product_price(product_name):
    """Fetch the price of a product from the database."""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    query = "SELECT price FROM products WHERE LOWER(name) = LOWER(?)"
    cursor.execute(query, (product_name.strip(),))  # Normalize product name
    result = cursor.fetchone()
    conn.close()
    return result[0] if result else 0  # Return price or 0 if not found

# In[57]:
valid_extensions = ('.jpg', '.jpeg', '.png', '.JPG', '.JPEG', '.PNG')
model_filenames = [f for f in os.listdir(model_folder) if f.lower().endswith(valid_extensions)]

if len(sys.argv) > 1:
    scene_filenames = sys.argv[1:]  # Use filenames passed as arguments
else:
    scene_filenames = ['e4.png']  # Default value if no arguments are provided

# Read images using os.path.join and verify image loaded successfully
im_scene_list_original = []
for name in scene_filenames:
    img_path = os.path.join(scene_folder, name)
    im = cv2.imread(img_path)
    if im is None:
        continue
    im_scene_list_original.append(cv2.cvtColor(im, cv2.COLOR_BGR2RGB))

im_model_list_original = []
for name in model_filenames:
    img_path = os.path.join(model_folder, name)
    im = cv2.imread(img_path)
    if im is None:
        continue
    im_model_list_original.append(cv2.cvtColor(im, cv2.COLOR_BGR2RGB))

# Resize scene images to smaller dimensions
im_scene_list_original = [
    cv2.resize(im, (int(im.shape[1] * 0.8), int(im.shape[0] * 0.8)), interpolation=cv2.INTER_AREA)
    for im in im_scene_list_original
]

# Use OpenCV's built-in SIFT
sift = cv2.SIFT_create()

# In[58]:
im_model_list = []
model_labels = []

for im, label in zip(im_model_list_original, model_filenames):
    aspect = im.shape[0] / im.shape[1]
    # Resize model images
    for s in (360,):
        im_resized = cv2.resize(im, (s, int(s * aspect)))
        im_model_list.append(im_resized)
        model_labels.append(label)
    # Gaussian blur on original images
    for sigma in (1.5, 3, 5):
        k = int(np.ceil(3 * sigma))
        im_model_list.append(cv2.GaussianBlur(im, (2 * k + 1, 2 * k + 1), sigma))
        model_labels.append(label)

# Free up originals
del im_model_list_original
gc.collect()

# In[ ]:
model_names = {}
for name in listdir(model_folder):
    simplified_name = name.rsplit('_', 1)[-1].split('.')[0]
    model_names[name] = simplified_name

# In[59]:
train_dict = {1: ['fsrcnn', os.path.join('.', 'weights', 'FSRCNN-small_x4.pb')],
              2: ['espcn', os.path.join('.', 'weights', 'ESPCN_x4.pb')],
              3: ['edsr', os.path.join('.', 'weights', 'EDSR_x4.pb')],
              4: ['lapsrn', os.path.join('.', 'weights', 'LapSRN_x4.pb')]}
nn_used = 4

sr = cv2.dnn_superres.DnnSuperResImpl_create()
sr.readModel(train_dict[nn_used][1])
sr.setModel(train_dict[nn_used][0], 4)

# Upsample scene images
im_scene_list = [sr.upsample(im) for im in im_scene_list_original]
# Free original scene list after upsampling
del im_scene_list_original
gc.collect()

# In[60]:
homography_kw = dict(match_distance_threshold=0.88, ransacReprojThreshold=1.)
peaks_kw = dict(height=0.3, distance=0)

matcher_matrix = find_matcher_matrix(im_scene_list, im_model_list, K=15, peaks_kw=peaks_kw, homography_kw=homography_kw)

# In[61]:
new_labels = [model_names[l] for l in model_labels]

grand_total = 0  # Initialize grand total for all scenes
detected_items = []  # List to store detected items and their prices

for i in range(len(im_scene_list)):
    scene_name = scene_filenames[i]

    color_threshold = 15
    overlap_threshold = 0.5
    bbox_props = find_bboxes(matcher_matrix[i], new_labels, color_distance_threshold=color_threshold, min_match_threshold=6, bbox_overlap_threshold=overlap_threshold)
    scene_total = 0  # Initialize total price for the scene
    processed_products = set()  # Set to track unique products in this scene

    w, h, dpi = 960, 720, 75
    fig, ax = plt.subplots(figsize=(w / dpi, h / dpi), dpi=dpi)

    visualize_detections(im_scene_list[i], bbox_props, annotation_offset=100, ax=ax, draw_invalid_bbox=0)
    fig.suptitle(scene_name)
    fig.tight_layout(pad=0.5)
    output_path = os.path.join(results_folder, f'found_{scene_name}')
    fig.savefig(output_path, dpi=dpi)
    plt.close(fig)

    print_detections(bbox_props)
for bbox in bbox_props:
    if 'model' in bbox:  # Use 'model' key to identify the product
        product_name = bbox["model"]
        # Instead of using a detailed key with position, use only the product name
        if product_name not in processed_products:  # Process only one detection per product
            print(f"Detected product: {product_name}")
            product_price = fetch_product_price(product_name)  # Fetch price from database
            print(f"Price fetched: {product_price}")
            if product_price > 0:  # Only add valid prices
                scene_total += product_price
                processed_products.add(product_name)  # Mark this product name as processed
                detected_items.append({
                    "scene": scene_name,
                    "product": product_name,
                    "price": product_price,
                    "bbox": bbox  # Include bounding box details if needed
                })
    else:
        print(f"Warning: 'model' key missing in bbox: {bbox}")

    grand_total += scene_total  # Add scene total to grand total
    print(f"Total price for scene '{scene_name}': {scene_total:.2f}")
    print(f"Export successful: {output_path}")
    # Clean up variables related to this scene
    del bbox_props, processed_products
    gc.collect()

# Export detected items to a TXT file
txt_file = os.path.join(results_folder, "detected_items.txt")
with open(txt_file, "w") as f:
    for item in detected_items:
        f.write(f"Product: {item['product']}\n")
        f.write(f"Price: {item['price']:.2f}\n")
        f.write("\n")

print(f"Detected items exported to {txt_file}")